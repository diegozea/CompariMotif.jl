var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"import CompariMotif\nusing Markdown\nMarkdown.parse(read(joinpath(pkgdir(CompariMotif), \"README.md\"), String))","category":"section"},{"location":"#Public-API","page":"Home","title":"Public API","text":"","category":"section"},{"location":"#Internal-API","page":"Home","title":"Internal API","text":"","category":"section"},{"location":"#CompariMotif.ComparisonOptions","page":"Home","title":"CompariMotif.ComparisonOptions","text":"ComparisonOptions\n\nReusable configuration object for CompariMotif comparisons.\n\nConstruct once with ComparisonOptions(; kwargs...) and reuse across many compare calls.\n\nKeywords\n\nalphabet::Symbol = :protein: comparison alphabet (:protein, :dna, or :rna).\nmin_shared_positions::Int = 2: minimum number of matched, non-wildcard positions required for a hit.\nnormalized_ic_cutoff::Real = 0.5: minimum normalized information content.\nmatchfix::Union{MatchFixMode, Symbol, AbstractString} = MatchFixNone: fixed-position matching mode. Accepted symbol/string aliases are: none, query_fixed (query), search_fixed (search), both_fixed (both).\nmismatches::Int = 0: tolerated count of defined-position mismatches.\nallow_ambiguous_overlap::Bool = true: whether partial class overlaps are allowed as complex matches.\nmax_variants::Int = 10_000: maximum expanded variants per motif.\n\nExamples\n\njulia> using CompariMotif\n\njulia> opts = ComparisonOptions(; alphabet = :rna);\n\njulia> String(opts.alphabet)\n\"ACGU\"\n\nSee also MatchFixMode, compare, ComparisonResult.\n\n\n\n\n\n","category":"type"},{"location":"#CompariMotif.ComparisonOptions-Tuple{}","page":"Home","title":"CompariMotif.ComparisonOptions","text":"ComparisonOptions(; kwargs...) -> ComparisonOptions\n\nConstruct a reusable options object for motif comparisons.\n\njulia> using CompariMotif\n\njulia> opts = ComparisonOptions(; alphabet = :dna, min_shared_positions = 1);\n\njulia> String(opts.alphabet)\n\"ACGT\"\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif.ComparisonResult","page":"Home","title":"CompariMotif.ComparisonResult","text":"ComparisonResult\n\nResult record produced by compare for one query/search motif pair.\n\nFields:\n\nquery, search: original input motifs.\nnormalized_query, normalized_search: canonicalized motifs used internally.\nmatched: whether the best-scoring valid alignment passed all thresholds.\nquery_relationship, search_relationship: human-readable relationship labels.\nmatched_pattern: consensus/overlap pattern for the selected alignment.\nmatched_positions: count of matched non-wildcard positions.\nmatch_ic: total information content for matched positions.\nnormalized_ic: match_ic normalized by the lower motif information content.\ncore_ic: information content normalized by core overlap length.\nscore: derived summary score (normalized_ic * matched_positions).\nquery_information, search_information: total information content per motif.\n\nSee also ComparisonOptions, normalize_motif, to_column_table.\n\n\n\n\n\n","category":"type"},{"location":"#CompariMotif.MatchFixMode","page":"Home","title":"CompariMotif.MatchFixMode","text":"MatchFixMode\n\nFixed-position matching behavior used by CompariMotif:\n\nMatchFixNone: no fixed-position requirement.\nMatchFixQueryFixed: fixed query positions must have exact fixed matches.\nMatchFixSearchFixed: fixed search positions must have exact fixed matches.\nMatchFixBothFixed: enforce fixed-position matching on both motifs.\n\nUsed by the matchfix keyword in ComparisonOptions.\n\n\n\n\n\n","category":"type"},{"location":"#CompariMotif.compare","page":"Home","title":"CompariMotif.compare","text":"compare(a::AbstractString, b::AbstractString, options::ComparisonOptions) -> ComparisonResult\ncompare(motifs::AbstractVector{<:AbstractString},\n        db::AbstractVector{<:AbstractString},\n        options::ComparisonOptions) -> Matrix{ComparisonResult}\ncompare(motifs::AbstractVector{<:AbstractString},\n        options::ComparisonOptions) -> Matrix{ComparisonResult}\n\nCompare motifs according to the CompariMotif scoring scheme described in Edwards et al. (2008).\n\nPairwise mode compares one query motif against one search motif.\nMatrix mode computes all pairwise query-vs-database comparisons.\nAll-vs-all mode is a convenience alias for compare(motifs, motifs, options).\n\nExamples\n\njulia> using CompariMotif\n\njulia> options = ComparisonOptions(; min_shared_positions = 1, normalized_ic_cutoff = 0.0);\n\njulia> result = compare(\"RKLI\", \"R[KR]L[IV]\", options);\n\njulia> result.matched\ntrue\n\nConfigure thresholds and matching semantics with ComparisonOptions. The result matrix has size (length(motifs), length(db)). Returns a ComparisonResult. Use normalize_motif for deterministic motif canonicalization. Convert results to column tables with to_column_table.\n\n\n\n\n\n","category":"function"},{"location":"#CompariMotif.compare-Tuple{AbstractString, AbstractString, ComparisonOptions}","page":"Home","title":"CompariMotif.compare","text":"compare(a::AbstractString, b::AbstractString, options::ComparisonOptions) -> ComparisonResult\n\nPairwise motif comparison.\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif.compare-Tuple{AbstractVector{<:AbstractString}, AbstractVector{<:AbstractString}, ComparisonOptions}","page":"Home","title":"CompariMotif.compare","text":"compare(motifs, db, options) -> Matrix{ComparisonResult}\n\nCompare all query motifs against all search-database motifs.\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif.compare-Tuple{AbstractVector{<:AbstractString}, ComparisonOptions}","page":"Home","title":"CompariMotif.compare","text":"compare(motifs, options) -> Matrix{ComparisonResult}\n\nConvenience all-vs-all matrix mode.\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif.normalize_motif-Tuple{AbstractString}","page":"Home","title":"CompariMotif.normalize_motif","text":"normalize_motif(motif::AbstractString; alphabet::Symbol = :protein) -> String\n\nParse and canonicalize a motif expression into a deterministic representation. Supported syntax includes fixed residues from the selected alphabet, bracket classes (including negation), x/X/. wildcards, ^/$ termini, and {n}/{m,n} repeat quantifiers. Grouping with (...) and alternation with | are also supported.\n\nWildcard tokens x, X, and . are equivalent and each means \"any residue\" in the selected alphabet (:protein, :dna, or :rna).\n\nExamples\n\njulia> using CompariMotif\n\njulia> normalize_motif(\"r[kR].{0,1}l\")\n\"R[RK]x{0,1}L\"\n\nConfigure thresholds and matching semantics with ComparisonOptions. Compute similarities with compare.\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif.to_column_table-Tuple{AbstractMatrix{<:ComparisonResult}}","page":"Home","title":"CompariMotif.to_column_table","text":"to_column_table(results::AbstractMatrix{<:ComparisonResult}) -> NamedTuple\n\nConvert a result matrix to a column table with query_index and search_index.\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif.to_column_table-Tuple{AbstractVector{<:ComparisonResult}}","page":"Home","title":"CompariMotif.to_column_table","text":"to_column_table(results::AbstractVector{<:ComparisonResult}) -> NamedTuple\n\nConvert a result vector to a column table with result_index.\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif.to_column_table-Tuple{ComparisonResult}","page":"Home","title":"CompariMotif.to_column_table","text":"to_column_table(results) -> NamedTuple\n\nConvert comparison results into a column-oriented NamedTuple where each key is a column name and each value is a vector column.\n\nto_column_table(::ComparisonResult) returns a one-row table.\nto_column_table(::AbstractVector{<:ComparisonResult}) adds result_index.\nto_column_table(::AbstractMatrix{<:ComparisonResult}) adds query_index and search_index with one row per matrix cell in deterministic row-major order.\n\nThe returned object can be converted to a DataFrame or written using CSV.write without requiring either dependency in the package itself.\n\nExamples\n\njulia> using CompariMotif, DataFrames\n\njulia> motifs = [\"RKLI\", \"R[KR]L[IV]\"];\n\njulia> options = ComparisonOptions(; min_shared_positions = 1, normalized_ic_cutoff = 0.0);\n\njulia> table = to_column_table(compare(motifs, options));\n\njulia> df = DataFrame(table);\n\njulia> show(select(df, [:query_index, :search_index, :query, :search, :query_relationship]), allrows = true, allcols = true, truncate = 0)\n4×5 DataFrame\n Row │ query_index  search_index  query       search      query_relationship\n     │ Int64        Int64         String      String      String\n─────┼───────────────────────────────────────────────────────────────────────\n   1 │           1             1  RKLI        RKLI        Exact Match\n   2 │           1             2  RKLI        R[KR]L[IV]  Variant Match\n   3 │           2             1  R[KR]L[IV]  RKLI        Degenerate Match\n   4 │           2             2  R[KR]L[IV]  R[KR]L[IV]  Exact Match\n\nCompute similarities with compare. Returns a ComparisonResult.\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif.ResidueClass","page":"Home","title":"CompariMotif.ResidueClass","text":"ResidueClass\n\nResidue set encoded as a ResidueMask.\n\n\n\n\n\n","category":"type"},{"location":"#CompariMotif.ResidueMask","page":"Home","title":"CompariMotif.ResidueMask","text":"ResidueMask\n\nBit-mask representation used for residue-set operations.\n\n\n\n\n\n","category":"type"},{"location":"#CompariMotif._canonical_token-Tuple{CompariMotif._Position, ComparisonOptions}","page":"Home","title":"CompariMotif._canonical_token","text":"_canonical_token(position::_Position, options::ComparisonOptions) -> String\n\nRender one parsed position into deterministic canonical motif syntax.\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif._class_mask-Tuple{AbstractString, ComparisonOptions}","page":"Home","title":"CompariMotif._class_mask","text":"_class_mask(raw::AbstractString, options::ComparisonOptions) -> ResidueMask\n\nParse a bracket class body into a residue mask.\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif._coerce_matchfix-Tuple{AbstractString}","page":"Home","title":"CompariMotif._coerce_matchfix","text":"_coerce_matchfix(mode::AbstractString) -> MatchFixMode\n\nNormalize string aliases into a concrete MatchFixMode.\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif._coerce_matchfix-Tuple{MatchFixMode}","page":"Home","title":"CompariMotif._coerce_matchfix","text":"_coerce_matchfix(mode::MatchFixMode) -> MatchFixMode\n\nReturn the match-fix mode unchanged.\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif._coerce_matchfix-Tuple{Symbol}","page":"Home","title":"CompariMotif._coerce_matchfix","text":"_coerce_matchfix(mode::Symbol) -> MatchFixMode\n\nNormalize symbol aliases into a concrete MatchFixMode.\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif._compare_parsed-Tuple{CompariMotif._ParsedMotif, CompariMotif._ParsedMotif, ComparisonOptions}","page":"Home","title":"CompariMotif._compare_parsed","text":"_compare_parsed(parsed_query, parsed_search, options) -> ComparisonResult\n\nCompare two already-parsed motifs.\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif._compare_positions-Tuple{CompariMotif._Position, CompariMotif._Position, ComparisonOptions}","page":"Home","title":"CompariMotif._compare_positions","text":"_compare_positions(qpos, spos, options)\n\nCompare one query/search position pair and return matching diagnostics.\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif._empty_result_columns-Tuple{Int64}","page":"Home","title":"CompariMotif._empty_result_columns","text":"_empty_result_columns(nrows::Int) -> NamedTuple\n\nAllocate typed result columns for nrows rows.\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif._evaluate_alignment-Tuple{CompariMotif._MotifVariant, CompariMotif._MotifVariant, Int64, ComparisonOptions}","page":"Home","title":"CompariMotif._evaluate_alignment","text":"_evaluate_alignment(query_variant, search_variant, shift, options)\n\nEvaluate one concrete shift between two expanded motif variants. Returns _Candidate when all thresholds pass, otherwise nothing.\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif._expand_variants-Tuple{CompariMotif._ParsedMotif, ComparisonOptions}","page":"Home","title":"CompariMotif._expand_variants","text":"_expand_variants(parsed::_ParsedMotif, options::ComparisonOptions) -> Vector{_MotifVariant}\n\nExpand ranged-repeat motifs into concrete variant sequences.\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif._is_better-Tuple{CompariMotif._Candidate, Union{Nothing, CompariMotif._Candidate}}","page":"Home","title":"CompariMotif._is_better","text":"_is_better(candidate::_Candidate, best::Union{Nothing, _Candidate}) -> Bool\n\nApply deterministic candidate ordering:\n\nhigher match_ic, 2) more matched positions, 3) more exact fixed matches.\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif._is_fixed-Tuple{CompariMotif._Position}","page":"Home","title":"CompariMotif._is_fixed","text":"_is_fixed(pos::_Position) -> Bool\n\nReturn true when pos encodes exactly one residue.\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif._is_terminus-Tuple{CompariMotif._Position}","page":"Home","title":"CompariMotif._is_terminus","text":"_is_terminus(pos::_Position) -> Bool\n\nReturn true when pos is a terminus anchor (^ or $).\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif._is_wildcard-Tuple{CompariMotif._Position, ComparisonOptions}","page":"Home","title":"CompariMotif._is_wildcard","text":"_is_wildcard(pos::_Position, options::ComparisonOptions) -> Bool\n\nReturn true when pos matches all residues in the selected alphabet.\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif._mask_from_char-Tuple{Char, ComparisonOptions}","page":"Home","title":"CompariMotif._mask_from_char","text":"_mask_from_char(char::Char, options::ComparisonOptions) -> ResidueMask\n\nReturn the residue mask for one alphabet character.\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif._mask_to_chars-Tuple{UInt32, ComparisonOptions}","page":"Home","title":"CompariMotif._mask_to_chars","text":"_mask_to_chars(mask::ResidueMask, options::ComparisonOptions; as_lowercase = false) -> Vector{Char}\n\nMaterialize residues represented by a mask in canonical alphabet order.\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif._mask_to_symbol-Tuple{UInt32, ComparisonOptions}","page":"Home","title":"CompariMotif._mask_to_symbol","text":"_mask_to_symbol(mask::ResidueMask, options::ComparisonOptions; as_lowercase = false, wildcard_symbol = \"x\") -> String\n\nRender one residue mask as canonical motif syntax.\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif._match_symbol-Tuple{CompariMotif._Position, CompariMotif._Position, UInt32, CompariMotif._RelationshipType, Bool, ComparisonOptions}","page":"Home","title":"CompariMotif._match_symbol","text":"_match_symbol(qpos, spos, intersection, relation, mismatch, options) -> String\n\nRender one output symbol for the overlap pattern.\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif._parse_motif-Tuple{AbstractString, ComparisonOptions}","page":"Home","title":"CompariMotif._parse_motif","text":"_parse_motif(motif::AbstractString, options::ComparisonOptions) -> _ParsedMotif\n\nParse one motif string into canonical internal representation.\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif._parse_repeat_quantifier-Tuple{AbstractString, Int64}","page":"Home","title":"CompariMotif._parse_repeat_quantifier","text":"_parse_repeat_quantifier(text::AbstractString, i::Int) -> (Int, Int, Int)\n\nParse optional repeat quantifier at index i, returning (min, max, next_index).\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif._position_ic-Tuple{CompariMotif._Position, ComparisonOptions}","page":"Home","title":"CompariMotif._position_ic","text":"_position_ic(pos::_Position, options::ComparisonOptions) -> Float64\n\nCompute information content for one parsed position.\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif._query_fixed_required-Tuple{MatchFixMode}","page":"Home","title":"CompariMotif._query_fixed_required","text":"_query_fixed_required(mode::MatchFixMode) -> Bool\n\nReturn true when query fixed residues must match exactly.\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif._search_fixed_required-Tuple{MatchFixMode}","page":"Home","title":"CompariMotif._search_fixed_required","text":"_search_fixed_required(mode::MatchFixMode) -> Bool\n\nReturn true when search fixed residues must match exactly.\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif._set_result_row!-Tuple{NamedTuple, Int64, ComparisonResult}","page":"Home","title":"CompariMotif._set_result_row!","text":"_set_result_row!(columns, row::Int, result::ComparisonResult)\n\nWrite one ComparisonResult into preallocated column vectors.\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif._variant_count-Tuple{Vector{CompariMotif._Token}}","page":"Home","title":"CompariMotif._variant_count","text":"_variant_count(tokens::Vector{_Token}) -> BigInt\n\nReturn the number of expanded variants implied by repeat ranges.\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif.is_fixed-Tuple{CompariMotif.ResidueClass}","page":"Home","title":"CompariMotif.is_fixed","text":"is_fixed(a::ResidueClass) -> Bool\n\nReturn true when the residue class contains exactly one residue.\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif.is_subset-Tuple{CompariMotif.ResidueClass, CompariMotif.ResidueClass}","page":"Home","title":"CompariMotif.is_subset","text":"is_subset(a::ResidueClass, b::ResidueClass) -> Bool\n\nReturn true when every residue in a is also in b.\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif.is_wildcard-Tuple{CompariMotif.ResidueClass, ComparisonOptions}","page":"Home","title":"CompariMotif.is_wildcard","text":"is_wildcard(a::ResidueClass, opts::ComparisonOptions) -> Bool\n\nReturn true when the residue class spans the full selected alphabet.\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif.overlaps-Tuple{CompariMotif.ResidueClass, CompariMotif.ResidueClass}","page":"Home","title":"CompariMotif.overlaps","text":"overlaps(a::ResidueClass, b::ResidueClass) -> Bool\n\nReturn true when two residue classes share at least one residue.\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif.unionclass-Tuple{CompariMotif.ResidueClass, CompariMotif.ResidueClass}","page":"Home","title":"CompariMotif.unionclass","text":"unionclass(a::ResidueClass, b::ResidueClass) -> ResidueClass\n\nReturn the set-union of two residue classes.\n\n\n\n\n\n","category":"method"}]
}
