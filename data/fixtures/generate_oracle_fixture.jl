#!/usr/bin/env julia

using Dates

const FIXTURES_DIR = @__DIR__
const ORACLE_RELATIVE_PATH = joinpath("tools", "comparimotif_V3.py")

# Backward-compatible defaults used by tests that include this script.
const MOTIF_SET = joinpath(FIXTURES_DIR, "regression_motifs.tsv")
const NORMALIZED_OUTPUT = joinpath(FIXTURES_DIR, "oracle_regression_normalized.tsv")
const ORACLE_NORMALIZED_COLUMNS = [
    "Motif1", "Motif2", "Sim1", "Sim2", "Match",
    "MatchPos", "MatchIC", "NormIC", "CoreIC", "Score", "Info1", "Info2"
]
const ALTERNATION_NORMALIZED_COLUMNS = [
    "Name1", "Name2", "Motif1", "Motif2", "Sim1", "Sim2", "Match",
    "MatchPos", "MatchIC", "NormIC", "CoreIC", "Score", "Info1", "Info2"
]

const FIXTURE_SPECS = (
    (
        name = "regression",
        motif_set = joinpath(FIXTURES_DIR, "regression_motifs.tsv"),
        output = joinpath(FIXTURES_DIR, "oracle_regression_normalized.tsv"),
        columns = ORACLE_NORMALIZED_COLUMNS,
        oracle_args = ["minshare=1", "normcut=0", "xgmml=F"]
    ),
    (
        name = "defaults",
        motif_set = joinpath(FIXTURES_DIR, "default_probe_motifs.tsv"),
        output = joinpath(FIXTURES_DIR, "oracle_default_probe_normalized.tsv"),
        columns = ORACLE_NORMALIZED_COLUMNS,
        oracle_args = ["minshare=2", "normcut=0.5", "matchfix=0",
            "mismatches=0", "overlaps=T", "xgmml=F"]
    ),
    (
        name = "alternation",
        motif_set = joinpath(FIXTURES_DIR, "alternation_probe_motifs.tsv"),
        output = joinpath(FIXTURES_DIR, "oracle_alternation_probe_normalized.tsv"),
        columns = ALTERNATION_NORMALIZED_COLUMNS,
        oracle_args = ["minshare=1", "normcut=0", "xgmml=F"]
    )
)

function read_motifs(path::String)
    motifs = String[]
    for line in eachline(path)
        stripped = strip(line)
        isempty(stripped) && continue
        startswith(stripped, '#') && continue
        cols = split(stripped, '\t')
        length(cols) == 1 || error("Invalid motif line: $line")
        push!(motifs, cols[1])
    end
    return motifs
end

function write_motif_file(path::String, motifs::Vector{String})
    open(path, "w") do io
        for (index, motif) in enumerate(motifs)
            name = "M$(lpad(string(index), 4, '0'))"
            println(io, name, '\t', motif)
        end
    end
end

function read_table(path::String)
    lines = readlines(path)
    isempty(lines) && error("Empty oracle output: $path")
    header = split(lines[1], '\t')
    rows = Dict{String, String}[]
    for line in Iterators.drop(lines, 1)
        stripped = strip(line)
        isempty(stripped) && continue
        cols = split(stripped, '\t')
        length(cols) == length(header) || error("Malformed oracle output row: $line")
        row = Dict{String, String}()
        for (key, value) in zip(header, cols)
            row[key] = value
        end
        push!(rows, row)
    end
    return header, rows
end

function normalize_rows(rows::Vector{Dict{String, String}}, columns::Vector{String} = ORACLE_NORMALIZED_COLUMNS)
    for row in rows
        for col in columns
            haskey(row, col) || error("Oracle output missing expected column: $col")
        end
    end
    sort!(rows; by = row -> Tuple(row[col] for col in columns))
    return rows
end

function write_normalized(path::String, rows::Vector{Dict{String, String}};
        columns::Vector{String} = ORACLE_NORMALIZED_COLUMNS)
    open(path, "w") do io
        println(io, "# Generated by data/fixtures/generate_oracle_fixture.jl")
        println(io, "# Date: ", Dates.format(now(), dateformat"yyyy-mm-ddTHH:MM:SS"))
        println(io, "# Source: CompariMotif oracle (black-box)")
        println(io, join(columns, '\t'))
        for row in rows
            println(io, join((row[col] for col in columns), '\t'))
        end
    end
end

function resolve_oracle_path(env::AbstractDict = ENV)
    slimsuite_root = strip(get(env, "SLiMSuite_PATH", ""))
    if !isempty(slimsuite_root)
        return joinpath(slimsuite_root, ORACLE_RELATIVE_PATH)
    end

    error(
        "Oracle executable not configured. Set `SLiMSuite_PATH` to a local clone of " *
        "https://github.com/slimsuite/SLiMSuite " *
        "(expected executable at `\$SLiMSuite_PATH/$ORACLE_RELATIVE_PATH`)."
    )
end

function _cleanup_oracle_logs!(dir::String)
    for entry in readdir(dir; join = true)
        isfile(entry) || continue
        filename = basename(entry)
        if occursin(r"^comparimotif.*\.log$", filename)
            rm(entry; force = true)
        end
    end
end

function _fixture_spec_map()
    return Dict(spec.name => spec for spec in FIXTURE_SPECS)
end

function _selected_specs(args::Vector{String})
    specs = _fixture_spec_map()
    if isempty(args) || any(arg -> arg == "all", args)
        return collect(FIXTURE_SPECS)
    end

    selected = NamedTuple[]
    for arg in args
        haskey(specs, arg) || error(
            "Unknown fixture set '$arg'. Allowed: " *
            join(sort!(collect(keys(specs))), ", ") * ", all"
        )
        push!(selected, specs[arg])
    end
    return selected
end

function _run_fixture!(oracle::String, spec)
    motifs = read_motifs(spec.motif_set)
    isempty(motifs) && error("No motifs found in fixture set: $(spec.motif_set)")

    mktempdir() do tmpdir
        motif_file = joinpath(tmpdir, "motifs.tsv")
        result_prefix = joinpath(tmpdir, "oracle")
        write_motif_file(motif_file, motifs)

        cmd_parts = [
            "python3", oracle, "motifs=$motif_file", "searchdb=$motif_file",
            "resfile=$result_prefix", "i=-1", "v=0", spec.oracle_args...
        ]
        cmd = Cmd(cmd_parts)
        @info "Running oracle fixture" fixture=spec.name cmd
        cd(tmpdir) do
            run(cmd)
            _cleanup_oracle_logs!(tmpdir)
        end

        raw_table = "$(result_prefix).compare.tdt"
        isfile(raw_table) || error("Oracle output not found: $raw_table")

        mkpath(FIXTURES_DIR)
        _, rows = read_table(raw_table)
        normalize_rows(rows, spec.columns)
        write_normalized(spec.output, rows; columns = spec.columns)
    end

    @info "Wrote fixtures" fixture=spec.name normalized=spec.output
end

function main(args::Vector{String} = ARGS)
    oracle = resolve_oracle_path()
    isfile(oracle) || error("Oracle executable not found: $oracle")
    _cleanup_oracle_logs!(pwd())

    for spec in _selected_specs(args)
        _run_fixture!(oracle, spec)
    end

    _cleanup_oracle_logs!(pwd())
end

if abspath(PROGRAM_FILE) == @__FILE__
    main(ARGS)
end
