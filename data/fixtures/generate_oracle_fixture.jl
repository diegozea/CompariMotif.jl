#!/usr/bin/env julia

using Dates

const FIXTURES_DIR = @__DIR__
const MOTIF_SET = joinpath(FIXTURES_DIR, "regression_motifs.tsv")
const NORMALIZED_OUTPUT = joinpath(FIXTURES_DIR, "oracle_regression_normalized.tsv")
const ORACLE_RELATIVE_PATH = joinpath("tools", "comparimotif_V3.py")
const ORACLE_NORMALIZED_COLUMNS = [
    "Motif1", "Motif2", "Sim1", "Sim2", "Match",
    "MatchPos", "MatchIC", "NormIC", "CoreIC", "Score", "Info1", "Info2"
]

function read_motifs(path::String)
    motifs = String[]
    for line in eachline(path)
        stripped = strip(line)
        isempty(stripped) && continue
        startswith(stripped, '#') && continue
        cols = split(stripped, '\t')
        length(cols) == 1 || error("Invalid motif line: $line")
        push!(motifs, cols[1])
    end
    return motifs
end

function write_motif_file(path::String, motifs::Vector{String})
    open(path, "w") do io
        for (index, motif) in enumerate(motifs)
            name = "M$(lpad(string(index), 4, '0'))"
            println(io, name, '\t', motif)
        end
    end
end

function read_table(path::String)
    lines = readlines(path)
    isempty(lines) && error("Empty oracle output: $path")
    header = split(lines[1], '\t')
    rows = Dict{String, String}[]
    for line in Iterators.drop(lines, 1)
        stripped = strip(line)
        isempty(stripped) && continue
        cols = split(stripped, '\t')
        length(cols) == length(header) || error("Malformed oracle output row: $line")
        row = Dict{String, String}()
        for (key, value) in zip(header, cols)
            row[key] = value
        end
        push!(rows, row)
    end
    return header, rows
end

function normalize_rows(rows::Vector{Dict{String, String}})
    for row in rows
        for col in ORACLE_NORMALIZED_COLUMNS
            haskey(row, col) || error("Oracle output missing expected column: $col")
        end
    end
    sort!(rows; by = row -> Tuple(row[col] for col in ORACLE_NORMALIZED_COLUMNS))
    return rows
end

function write_normalized(path::String, rows::Vector{Dict{String, String}})
    open(path, "w") do io
        println(io, "# Generated by data/fixtures/generate_oracle_fixture.jl")
        println(io, "# Date: ", Dates.format(now(), dateformat"yyyy-mm-ddTHH:MM:SS"))
        println(io, "# Source: CompariMotif oracle (black-box)")
        println(io, join(ORACLE_NORMALIZED_COLUMNS, '\t'))
        for row in rows
            println(io, join((row[col] for col in ORACLE_NORMALIZED_COLUMNS), '\t'))
        end
    end
end

function resolve_oracle_path(env::AbstractDict = ENV)
    slimsuite_root = strip(get(env, "SLiMSuite_PATH", ""))
    if !isempty(slimsuite_root)
        return joinpath(slimsuite_root, ORACLE_RELATIVE_PATH)
    end

    error(
        "Oracle executable not configured. Set `SLiMSuite_PATH` to a local clone of " *
        "https://github.com/slimsuite/SLiMSuite " *
        "(expected executable at `\$SLiMSuite_PATH/$ORACLE_RELATIVE_PATH`)."
    )
end

function main()
    oracle = resolve_oracle_path()
    isfile(oracle) || error("Oracle executable not found: $oracle")

    motifs = read_motifs(MOTIF_SET)
    isempty(motifs) && error("No motifs found in fixture set: $MOTIF_SET")

    mktempdir() do tmpdir
        motif_file = joinpath(tmpdir, "motifs.tsv")
        result_prefix = joinpath(tmpdir, "oracle")
        write_motif_file(motif_file, motifs)

        cmd = `python3 $oracle motifs=$motif_file searchdb=$motif_file resfile=$result_prefix i=-1 v=0 minshare=1 normcut=0 xgmml=F`
        @info "Running oracle" cmd
        run(cmd)

        raw_table = "$(result_prefix).compare.tdt"
        isfile(raw_table) || error("Oracle output not found: $raw_table")

        mkpath(FIXTURES_DIR)
        _, rows = read_table(raw_table)
        normalize_rows(rows)
        write_normalized(NORMALIZED_OUTPUT, rows)
    end

    @info "Wrote fixtures" normalized=NORMALIZED_OUTPUT
end

if abspath(PROGRAM_FILE) == @__FILE__
    main()
end
