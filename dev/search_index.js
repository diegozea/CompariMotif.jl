var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"import CompariMotif\nusing Markdown\nMarkdown.parse(read(joinpath(pkgdir(CompariMotif), \"README.md\"), String))","category":"section"},{"location":"#Public-API","page":"Home","title":"Public API","text":"","category":"section"},{"location":"#CompariMotif.compare-Tuple{String, String}","page":"Home","title":"CompariMotif.compare","text":"compare(a::String, b::String; kwargs...) -> ComparisonResult\n\nCompare two motifs and return the best relationship according to the CompariMotif scoring scheme described in Edwards et al. (2008).\n\nKeyword arguments:\n\nalphabet::Symbol = :protein: :protein or :dna.\nmin_shared_positions::Int = 2: minimum non-wildcard matched positions.\nnormalized_ic_cutoff::Real = 0.5: minimum normalized information content.\nmatchfix::Int = 0: fixed-position matching mode (0 none, 1 query fixed, 2 search fixed, 3 both).\nmismatches::Int = 0: tolerated defined-position mismatches.\nallow_ambiguous_overlap::Bool = true: allow partial class overlap.\nmax_variants::Int = 10000: maximum expanded variants per motif.\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif.compare-Tuple{Vector{String}, Vector{String}}","page":"Home","title":"CompariMotif.compare","text":"compare(motifs::Vector{String}, db::Vector{String}; kwargs...) -> Matrix{ComparisonResult}\n\nCompute all pairwise comparisons between query motifs and database motifs. The result matrix has size (length(motifs), length(db)).\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif.compare-Tuple{Vector{String}}","page":"Home","title":"CompariMotif.compare","text":"compare(motifs::Vector{String}; kwargs...) -> Matrix{ComparisonResult}\n\nConvenience method for all-vs-all motif comparison.\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif.normalize_motif-Tuple{String}","page":"Home","title":"CompariMotif.normalize_motif","text":"normalize_motif(motif::String; alphabet::Symbol = :protein) -> String\n\nParse and canonicalize a motif expression into a deterministic representation. Supported syntax includes fixed residues, bracket classes (including negation), x/. wildcards, ^/$ termini, and {m,n} (or (m,n)) repeat quantifiers.\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif.write_results_tsv-Tuple{AbstractString, Vector{String}, Vector{String}, Matrix{ComparisonResult}}","page":"Home","title":"CompariMotif.write_results_tsv","text":"write_results_tsv(path, motifs, db, results)\n\nWrite pairwise comparison results to a deterministic TSV file.\n\n\n\n\n\n","category":"method"}]
}
