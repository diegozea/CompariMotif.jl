var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"import CompariMotif\nusing Markdown\nMarkdown.parse(read(joinpath(pkgdir(CompariMotif), \"README.md\"), String))","category":"section"},{"location":"#Public-API","page":"Home","title":"Public API","text":"","category":"section"},{"location":"#CompariMotif.ComparisonOptions","page":"Home","title":"CompariMotif.ComparisonOptions","text":"ComparisonOptions\n\nReusable configuration object for CompariMotif comparisons.\n\nConstruct once with ComparisonOptions(; kwargs...) and reuse across many compare calls.\n\nKeywords\n\nalphabet::Symbol = :protein: comparison alphabet (:protein or :dna).\nmin_shared_positions::Int = 2: minimum number of matched, non-wildcard positions required for a hit.\nnormalized_ic_cutoff::Real = 0.5: minimum normalized information content.\nmatchfix::Union{MatchFixMode, Symbol, AbstractString} = MatchFixNone: fixed-position matching mode. Accepted symbol/string aliases are: none, query_fixed (query), search_fixed (search), both_fixed (both).\nmismatches::Int = 0: tolerated count of defined-position mismatches.\nallow_ambiguous_overlap::Bool = true: whether partial class overlaps are allowed as complex matches.\nmax_variants::Int = 10_000: maximum expanded variants per motif.\n\n\n\n\n\n","category":"type"},{"location":"#CompariMotif.ComparisonOptions-Tuple{}","page":"Home","title":"CompariMotif.ComparisonOptions","text":"ComparisonOptions(; kwargs...) -> ComparisonOptions\n\nCreate validated comparison options for compare.\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif.MatchFixMode","page":"Home","title":"CompariMotif.MatchFixMode","text":"MatchFixMode\n\nFixed-position matching behavior used by CompariMotif:\n\nMatchFixNone: no fixed-position requirement.\nMatchFixQueryFixed: fixed query positions must have exact fixed matches.\nMatchFixSearchFixed: fixed search positions must have exact fixed matches.\nMatchFixBothFixed: enforce fixed-position matching on both motifs.\n\n\n\n\n\n","category":"type"},{"location":"#CompariMotif.compare-Tuple{AbstractString, AbstractString, ComparisonOptions}","page":"Home","title":"CompariMotif.compare","text":"compare(a::AbstractString, b::AbstractString, options::ComparisonOptions) -> ComparisonResult\n\nCompare two motifs and return the best relationship according to the CompariMotif scoring scheme described in Edwards et al. (2008).\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif.compare-Tuple{AbstractVector{<:AbstractString}, AbstractVector{<:AbstractString}, ComparisonOptions}","page":"Home","title":"CompariMotif.compare","text":"compare(motifs::AbstractVector{<:AbstractString},\n        db::AbstractVector{<:AbstractString},\n        options::ComparisonOptions) -> Matrix{ComparisonResult}\n\nCompute all pairwise comparisons between query motifs and database motifs. The result matrix has size (length(motifs), length(db)).\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif.compare-Tuple{AbstractVector{<:AbstractString}, ComparisonOptions}","page":"Home","title":"CompariMotif.compare","text":"compare(motifs::AbstractVector{<:AbstractString},\n        options::ComparisonOptions) -> Matrix{ComparisonResult}\n\nConvenience method for all-vs-all motif comparison.\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif.normalize_motif-Tuple{AbstractString}","page":"Home","title":"CompariMotif.normalize_motif","text":"normalize_motif(motif::AbstractString; alphabet::Symbol = :protein) -> String\n\nParse and canonicalize a motif expression into a deterministic representation. Supported syntax includes fixed residues, bracket classes (including negation), x/. wildcards, ^/$ termini, and {m,n} (or (m,n)) repeat quantifiers.\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif.write_results_tsv-Tuple{AbstractString, AbstractVector{<:AbstractString}, AbstractVector{<:AbstractString}, Matrix{ComparisonResult}}","page":"Home","title":"CompariMotif.write_results_tsv","text":"write_results_tsv(path, motifs, db, results)\n\nWrite pairwise comparison results to a deterministic TSV file.\n\n\n\n\n\n","category":"method"}]
}
