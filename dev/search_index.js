var documenterSearchIndex = {"docs":
[{"location":"#CompariMotif","page":"Home","title":"CompariMotif","text":"CompariMotif.jl is a clean-room Julia implementation of the motif comparison workflow described in Edwards et al. (2008).","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"julia> using CompariMotif\n\njulia> motifs = [\"RKLI\", \"R[KR]L[IV]\", \"[KR]xLx[FYLIMVP]\", \"RxLE\"];\n\njulia> results = compare(motifs; min_shared_positions = 1, normalized_ic_cutoff = 0.0);\n\njulia> (results[3, 4].matched, results[3, 4].query_relationship, results[3, 4].matched_positions)\n(true, \"Degenerate Parent\", 2)\n\njulia> outfile = joinpath(mktempdir(), \"comparimotif_results.tsv\");\n\njulia> write_results_tsv(outfile, motifs, motifs, results);\n\njulia> isfile(outfile)\ntrue","category":"section"},{"location":"#Public-API","page":"Home","title":"Public API","text":"","category":"section"},{"location":"#CompariMotif.compare-Tuple{String, String}","page":"Home","title":"CompariMotif.compare","text":"compare(a::String, b::String; kwargs...) -> ComparisonResult\n\nCompare two motifs and return the best relationship according to the CompariMotif scoring scheme described in Edwards et al. (2008).\n\nKeyword arguments:\n\nalphabet::Symbol = :protein: :protein or :dna.\nmin_shared_positions::Int = 2: minimum non-wildcard matched positions.\nnormalized_ic_cutoff::Real = 0.5: minimum normalized information content.\nmatchfix::Int = 0: fixed-position matching mode (0 none, 1 query fixed, 2 search fixed, 3 both).\nmismatches::Int = 0: tolerated defined-position mismatches.\nallow_ambiguous_overlap::Bool = true: allow partial class overlap.\nmax_variants::Int = 10000: maximum expanded variants per motif.\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif.compare-Tuple{Vector{String}, Vector{String}}","page":"Home","title":"CompariMotif.compare","text":"compare(motifs::Vector{String}, db::Vector{String}; kwargs...) -> Matrix{ComparisonResult}\n\nCompute all pairwise comparisons between query motifs and database motifs. The result matrix has size (length(motifs), length(db)).\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif.compare-Tuple{Vector{String}}","page":"Home","title":"CompariMotif.compare","text":"compare(motifs::Vector{String}; kwargs...) -> Matrix{ComparisonResult}\n\nConvenience method for all-vs-all motif comparison.\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif.normalize_motif-Tuple{String}","page":"Home","title":"CompariMotif.normalize_motif","text":"normalize_motif(motif::String; alphabet::Symbol = :protein) -> String\n\nParse and canonicalize a motif expression into a deterministic representation. Supported syntax includes fixed residues, bracket classes (including negation), x/. wildcards, ^/$ termini, and {m,n} (or (m,n)) repeat quantifiers.\n\n\n\n\n\n","category":"method"},{"location":"#CompariMotif.write_results_tsv-Tuple{AbstractString, Vector{String}, Vector{String}, Matrix{ComparisonResult}}","page":"Home","title":"CompariMotif.write_results_tsv","text":"write_results_tsv(path, motifs, db, results)\n\nWrite pairwise comparison results to a deterministic TSV file.\n\n\n\n\n\n","category":"method"}]
}
